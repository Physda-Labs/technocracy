<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Technocracy</title>
    <!-- 1. Load Tailwind CSS for styling the UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. Load p5.js for the canvas animation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    
    <!-- 3. Custom styles for the page -->
    <style>
        body {
            /* Dark font that works well on a dark background */
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent scrolling */
        }
        /* Style the canvas container */
        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1; /* Behind the UI */
        }
        canvas {
            display: block;
            /* Clicks are no longer needed on individual characters */
            /* cursor: pointer; */ 
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">

    <!-- 4. The p5.js canvas will be inserted here by the script -->
    <div id="canvas-container"></div>

    <!-- 5. The UI elements, floating on top of the canvas -->
    <div class="relative z-10 p-6 max-w-lg mx-auto text-center">
        <h1 class="text-3xl font-bold text-white mb-2">Technocracy</h1>
        <p class="text-gray-400 mb-4">Ask a question, and 100 tiny warriors will share their thoughts. Click "Ask" to see their opinions!</p>
        
        <div class="flex flex-col sm:flex-row gap-2">
            <input 
                type="text" 
                id="question-input" 
                placeholder="Ask your question here..."
                class="flex-grow bg-gray-700 border border-gray-600 text-white rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
            <button 
                id="ask-button"
                class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-200 transform hover:scale-105"
            >
                Ask the Horde
            </button>

            <button 
                id="toggle-bubbles-button"
                class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg transition duration-200"
            >
                Toggle Bubbles
            </button>
        </div>
    </div>

    <!-- 6. The main p5.js script -->
    <script>
        // --- "PATH A" OPINION DATABASE ---
        // Opinions are now very short to fit in small bubbles
        const opinionDatabase = {
            positive: [
                "Yes!",
                "Glory!",
                "Brilliant!",
                "Go!",
                "A-ha!",
                "Huzzah!",
            ],
            negative: [
                "No!",
                "Madness!",
                "Regret!",
                "Bah!",
                "Never!",
                "Ugh."
            ],
            neutral: [
                "Hmm...",
                "Maybe.",
                "Meh.",
                "...",
                "Wait.",
                "Eh."
            ],
            chaotic: [
                "WAAAGH!",
                "Loot!",
                "Boom!",
                "RAWR!",
                "Mud!",
                "Heh!"
            ]
        };

        // --- GLOBAL VARIABLES ---
        let characters = [];
        const characterCount = 100;
        
        // HTML element references
        let askButton, toggleBubblesButton, canvasContainer, canvas;
        let canvasOffsetX = 0;
        let canvasOffsetY = 0;

        let areBubblesVisible = false; // Global toggle for bubbles

        // Camera and World Variables
        let currentScale = 1;
        let originX = 0;
        let originY = 0;
        let worldWidth, worldHeight;
        let minZoom;

        let spriteImg; 

        function preload() {
            // Make sure to have these files in the same folder as your
            // index.html, or provide the correct path.
            // Using placeholder images for now.
            spriteImg = loadImage('walk.png');
    
        }

        // --- P5.JS SETUP FUNCTION ---
        // Runs once when the page loads
        function setup() {
            // Create the canvas to fill the window and parent it
            canvasContainer = document.getElementById('canvas-container');
            canvas = createCanvas(windowWidth, windowHeight);
            canvas.parent(canvasContainer);
            
            // Set default drawing modes
            rectMode(CORNER);
            textAlign(CENTER, CENTER);
            textSize(12);

            // --- Set up world and camera ---
            worldWidth = windowWidth * 3;
            worldHeight = windowHeight * 3;
            originX = windowWidth / 2; // Start camera centered
            originY = windowHeight / 2;

            // Calculate the minimum scale needed to make the world fill the window
            let minScaleX = windowWidth / worldWidth;
            let minScaleY = windowHeight / worldHeight;
            minZoom = max(minScaleX, minScaleY); // Use the larger ratio to ensure both fit
            currentScale = minZoom; // <-- OPTIONAL: Start zoomed out to see the whole world

            // Get canvas offset
            let canvasRect = canvas.elt.getBoundingClientRect();
            canvasOffsetX = canvasRect.left;
            canvasOffsetY = canvasRect.top;

            // --- Create 100 unique characters ---
            for (let i = 0; i < characterCount; i++) {
                characters.push(new Character());
            }
            
            // --- Get HTML elements and attach listeners ---
            askButton = document.getElementById('ask-button');
            toggleBubblesButton = document.getElementById('toggle-bubbles-button'); // <-- ADDED

            // When "Ask" is clicked, generate new opinions for everyone
            askButton.addEventListener('click', () => {
                areBubblesVisible = true; // <-- ADDED: Show bubbles on new ask
                toggleBubblesButton.innerText = "Hide Bubbles"; // <-- ADDED: Update toggle text
                
                for (let char of characters) {
                    char.generateNewOpinion();
                    char.showOpinion = true; // Make the bubble appear
                }
                // Give user feedback
                askButton.innerText = "They are thinking...";
                setTimeout(() => {
                    askButton.innerText = "Ask Again?";
                }, 1000);
            });

            // --- ADDED THIS NEW LISTENER ---
            toggleBubblesButton.addEventListener('click', () => {
                // Flip the boolean
                areBubblesVisible = !areBubblesVisible; 
                
                // Update the button text
                if (areBubblesVisible) {
                    toggleBubblesButton.innerText = "Hide Bubbles";
                } else {
                    toggleBubblesButton.innerText = "Show Bubbles";
                }
            });
        }

        // --- P5.JS DRAW FUNCTION ---
        // Runs 60 times per second in a loop
        function draw() {
            // 1. Draw the dark landscape (the whole canvas is the floor now)
            background(30, 25, 40); // Dark grayish-purple floor
            
            // Zoom and Pan the Camera
            push(); // Save the canvas's original state (pre-camera)
            translate(originX, originY);
            scale(currentScale);

            // (Optional) Draw a faint border for the world
            noFill();
            stroke(255, 50); // Faint white
            strokeWeight(10 / currentScale); // Make stroke thinner as you zoom out
            rect(-worldWidth / 2, -worldHeight / 2, worldWidth, worldHeight);
            
            // 2. Draw the dark floor
            noStroke();
            // fill(30, 25, 40); // <-- This is now the background
            // rectMode(CORNER); // <-- No longer need to draw the floor rect
            // rect(0, floorY, width, floorHeight); // <-- REMOVED
            
            // --- 2.5D ILLUSION ---
            // Sort characters by their y-position.
            // This makes characters "lower" on screen draw on top of
            // characters "higher" on screen, creating a sense of depth.
            characters.sort((a, b) => a.y - b.y);

            // 3. Update and display every character
            for (let char of characters) {
                char.update();
                char.display();
            }

            pop(); // Restore the canvas state (so UI is not zoomed/panned)
        }
        
        // --- P5.JS INTERACTION FUNCTIONS ---

        // Runs when the mouse is pressed
        function mousePressed() {
            // Leave this blank for now, can new interactions.
            // This guard prevents clicks on the UI from doing anything
            if (mouseY < 150) return; 
        }

        function mouseDragged() {
            // 1. Prevent panning if touching the UI area
            if (mouseY < 150) return;

            // 2. Shift the origin by how much the mouse moved
            // (movedX and movedY are built-in p5.js variables)
            originX += movedX;
            originY += movedY;

            // 3. Clamp immediately so you can't drag the edge of the world into view
            clampOrigin();
        }


        function mouseWheel(event) {
            event.preventDefault();
            if (mouseY < 150) return;

            // 1. Calculate Usable Canvas Area
            const effectiveHeight = height; 
            const effectiveWidth = width;   

            // 2. Calculate the fresh minimum scale needed to fill the window
            const minScaleX = effectiveWidth / worldWidth;
            const minScaleY = effectiveHeight / worldHeight;
            
            // Use the local minScale variable for immediate accuracy
            // We add a tiny multiplier (1.001) to prevent 1px floating-point gaps
            const localMinScale = Math.max(minScaleX, minScaleY) * 1.001; 

            let s = event.deltaY > 0 ? 0.95 : 1.05;
            let newScale = currentScale * s;
            
            // 3. Constrain using the LOCAL variable, not the global minZoom
            newScale = constrain(newScale, localMinScale, 5); 

            if (newScale === currentScale) return;

            let worldX = (mouseX - originX) / currentScale;
            let worldY = (mouseY - originY) / currentScale;

            currentScale = newScale;

            originX = mouseX - (worldX * currentScale);
            originY = mouseY - (worldY * currentScale);

            clampOrigin();
        }

        // Runs when the browser window is resized
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            
            // Recalculate minZoom based on new window size
            let minScaleX = windowWidth / worldWidth;
            let minScaleY = windowHeight / worldHeight;
            minZoom = max(minScaleX, minScaleY);

            // If the new window requires a larger zoom to fill it,
            // force currentScale to match immediately.
            if (currentScale < minZoom) {
                currentScale = minZoom;
            }

            let canvasRect = canvas.elt.getBoundingClientRect();
            canvasOffsetX = canvasRect.left;
            canvasOffsetY = canvasRect.top;
            
            clampOrigin();
        }

        
        // Clamp the originX and originY to prevent showing blank space
        function clampOrigin() {
            // 1. Calculate the scaled dimensions of the world
            let scaledWorldW = worldWidth * currentScale;
            let scaledWorldH = worldHeight * currentScale;
            
            // 2. Clamp Origin X
            if (scaledWorldW <= width + 1) {
                // If scaled world is smaller or equal to canvas width, force it to be centered.
                originX = width / 2;
            } else {
                // If zoomed in, constrain panning.
                let scaledHalfWorldW = scaledWorldW / 2;
                let minX = width - scaledHalfWorldW; // Right edge of world touches right edge of screen
                let maxX = scaledHalfWorldW;          // Left edge of world touches left edge of screen
                
                originX = constrain(originX, minX, maxX);
            }
            
            // 3. Clamp Origin Y
            if (scaledWorldH <= height + 1) {
                // If scaled world is smaller or equal to canvas height, force it to be centered.
                originY = height / 2;
            } else {
                // If zoomed in, constrain panning.
                let scaledHalfWorldH = scaledWorldH / 2;
                let minY = height - scaledHalfWorldH;
                let maxY = scaledHalfWorldH;

                originY = constrain(originY, minY, maxY);
            }
        }

        // --- CHARACTER CLASS ---
        // A blueprint for making characters
        class Character {
            constructor() {
                // Position and Movement
                this.x = random(-worldWidth / 2, worldWidth / 2); // Start in the world
                this.y = random(0, worldHeight / 2); // Start in "bottom half" of world
                this.vx = random(-5, 5); // Velocity x
                this.vy = random(-3, 3); // Velocity y (slower vertical)
                
                


                // Generative Look
                this.img = spriteImg; 

                // CHANGE THESE NUMBERS TO MATCH PNG:
                this.frameWidth = 64;   // How wide is ONE character in pixels?
                this.frameHeight = 66;  // How tall is ONE character?
                this.totalFrames = 9;   // How many walking frames in the sheet?
                
                this.currentFrame = 0;  // Tracks which frame we are on (0, 1, 2...)
                this.animSpeed = 0.4;  // How fast the legs move (0.1 to 0.3 is good)
                this.animTimer = 0;     // Internal counter for timing


                this.size = this.frameHeight * random(2.0, 2.4);

                // We can still use a random color for tinting!
                this.tintColor = color(random(150, 255), random(150, 255), random(150, 255));
                this.tintColor.setAlpha(255); // Make sure it's not transparent


                // Personality and Opinion
                this.personality = random(Object.keys(opinionDatabase));
                this.currentOpinion = "..."; // Default
                this.showOpinion = false; // Bubble is hidden by default
            }

            // Method to get a new opinion
            generateNewOpinion() {
                let options = opinionDatabase[this.personality];
                this.currentOpinion = random(options);
            }

            // Method to update position
            update() {
                // Apply velocity
                this.x += this.vx;
                this.y += this.vy;

                // Add random jitter to movement
                this.vx += random(-0.1, 0.1);
                this.vy += random(-0.05, 0.05);

                // Constrain/clamp speed
                this.vx = constrain(this.vx, -10, 10);
                this.vy = constrain(this.vy, -3.5, 3.5);

                // Bounce off world edges (no longer screen edges)
                if (this.x < -worldWidth / 2 || this.x > worldWidth / 2) {
                    this.vx *= -1;
                }
                // Bounce off floor and "ceiling" of their area
                if (this.y < 0 || this.y > worldHeight / 2) { // <-- CHANGED
                    this.vy *= -1;
                }
                
                // 1. Update the frame counter
                this.animTimer += this.animSpeed;
                    
                // 2. If timer passes 1, move to next frame
                if (this.animTimer > 1) {
                    this.animTimer = 0;
                    this.currentFrame++;
                    // 3. Loop back to start if we reach the end
                    if (this.currentFrame >= this.totalFrames) {
                        this.currentFrame = 0;
                    }
                }
            }


            // Method to draw the character
            display() {
                push(); // 1. Save the current drawing state
                
                // 2. Move to the character's position
                translate(this.x, this.y);

                // 3. DEPTH SCALE: Calculate scale based on Y position (2.5D effect)
                // Characters lower on screen (higher Y) are larger
                let s = map(this.y, 0, worldHeight / 2, 0.6, 1.2);
                scale(s);

                // 4. DIRECTION FLIP: Check velocity to see which way we are walking
                // If vx is negative (moving left), flip the coordinate system horizontally
                if (this.vx > 0) {
                    scale(-1, 1); 
                }

                // 5. DRAW THE SPRITE ANIMATION
                imageMode(CENTER);
                tint(this.tintColor); // Apply the random color tint

                // --- Calculate Animation Slices ---
                // Source X: Which frame is it on? (Frame Number * Width of one frame)
                let sx = this.currentFrame * this.frameWidth; 
                let sy = 0; // Top of the image (assuming a single-row sprite sheet)

                // Calculate the drawing dimensions to maintain aspect ratio
                let drawHeight = this.size;
                let drawWidth = (this.frameWidth * drawHeight) / this.frameHeight;

                // Draw the specific slice of the sprite sheet
                // image(img, destX, destY, destW, destH, sourceX, sourceY, sourceW, sourceH)
                image(
                    this.img,           // The sprite sheet image
                    0, -drawHeight / 2, // Destination X, Y (Shifted up so y=0 is feet)
                    drawWidth,          // Destination Width
                    drawHeight,         // Destination Height
                    sx, sy,             // Source X, Y (Where to slice from)
                    this.frameWidth,    // Source Width (Width of one frame)
                    this.frameHeight    // Source Height (Height of one frame)
                );

                noTint(); // Turn off tint so it doesn't affect other drawings

                // 6. DRAW SPEECH BUBBLE (Must be last to appear on top)
                if (this.showOpinion && areBubblesVisible) {
                    
                    // If the character is flipped (walking left), the text will be backwards.
                    // We must flip the coordinate system BACK to normal just for the text.
                    if (this.vx > 0) {
                        scale(-1, 1); 
                    }

                    rectMode(CENTER);
                    textAlign(CENTER, CENTER);
                    
                    let bubbleH = 25;
                    let bubbleW = textWidth(this.currentOpinion) + 16;
                    
                    // Position the bubble above the head.
                    // We use 1.1 to ensure it clears the top of the sprite.
                    let bubbleY = -this.size * 1.1 - (bubbleH / 2); 
                    
                    // Draw the Triangle Pointer
                    fill(255);
                    stroke(0);
                    strokeWeight(2);
                    triangle(
                        -7, bubbleY + bubbleH / 2 - 1, // Left corner
                        7, bubbleY + bubbleH / 2 - 1, // Right corner
                        0, -this.size * 0.95          // Tip (pointing to head)
                    );
                    
                    // Draw the Bubble Rectangle
                    fill(255); // White background
                    stroke(0);
                    strokeWeight(2);
                    rect(0, bubbleY, bubbleW, bubbleH, 8); // Rounded corners
                    
                    // Draw the Text
                    fill(0); // Black text
                    noStroke();
                    textSize(12);
                    text(this.currentOpinion, 0, bubbleY + 1);
                }

                pop(); // Restore the drawing state for the next character
            }
        }
    </script>
</body>
</html>