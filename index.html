<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Technocracy</title>
    <style>
        /* RESET & BASIC STYLING */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #222;
            overflow: hidden; /* Prevent scrollbars */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* UI OVERLAY */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 25px;
            border-radius: 30px;
            display: flex;
            gap: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            z-index: 1000;
            width: 90%;
            max-width: 600px;
        }

        #question-input {
            flex-grow: 1;
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 20px;
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s;
        }

        #question-input:focus {
            border-color: #6a11cb;
        }

        #ask-btn {
            padding: 10px 25px;
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            color: white;
            border: none;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.2s;
        }

        #ask-btn:hover {
            opacity: 0.9;
        }

        #ask-btn:active {
            transform: scale(0.95);
        }

        /* CANVAS */
        canvas {
            display: block;
            background-color: #333333; /* Requested Dark Background */
        }
    </style>
</head>
<body>

    <!-- UI CONTAINER -->
    <div id="ui-layer">
        <input type="text" id="question-input" placeholder="Ask the villagers something...">
        <button id="ask-btn">Ask</button>
    </div>

    <!-- GAME CANVAS -->
    <canvas id="gameCanvas"></canvas>

    <script>
        // ==========================================
        // CONFIGURATION & ASSETS
        // ==========================================
        
        // PLACE YOUR IMAGE FILE HERE
        // Ensure your file is named 'sprite.png' and is in the same folder as this .html file.
        // It should be a 9x4 grid (9 columns, 4 rows).
        const SPRITE_SRC = './sprite.png'; 

        // CONSTANTS
        const NUM_CHARACTERS = 100;
        // Reduced size for "Smaller" request
        const CHAR_WIDTH = 48;  
        const CHAR_HEIGHT = 48; 
        const HITBOX_RADIUS = 10; 
        // Reduced speed for "Slower" request
        const SPEED = 0.6;
        const ANIMATION_SPEED = 0.2;

        // ==========================================
        // CLASSES
        // ==========================================

        /**
         * BRAIN: Handles the "Thinking" logic. 
         * Currently random, ready for LLM integration.
         */
        class Brain {
            constructor() {
                this.responses = [
                    "I love this!", "I'm hungry.", "What is that?", "Yes.", "No way!",
                    "Maybe later.", "The sky is dark.", "Where am I?", "Hello!", "Running late!",
                    "Did you hear that?", "Nice shoes.", "I want pizza.", "Hmm...", "Interesting.",
                    "Who are you?", "Code is poetry.", "Walking is fun.", "Don't touch me.", "I'm tired."
                ];
            }

            // Future: Make this async to call an API
            thinkOfAnswer(question) {
                const index = Math.floor(Math.random() * this.responses.length);
                return this.responses[index];
            }
        }

        /**
         * CHARACTER: Logic for a single entity.
         */
        class Character {
            constructor(id, x, y, spriteImage) {
                this.id = id;
                this.x = x;
                this.y = y;
                
                // Velocity
                this.vx = (Math.random() - 0.5) * SPEED;
                this.vy = (Math.random() - 0.5) * SPEED;
                
                // Visuals
                this.image = spriteImage;
                this.brain = new Brain();
                
                // Animation State
                this.frameIndex = 0;
                this.row = 2; // 0:Up, 1:Left, 2:Down, 3:Right
                this.tickCount = 0;
                
                // Interaction State
                this.state = 'WANDERING'; // WANDERING, PREPARING, TALKING
                this.speechText = "";
                this.speechTimer = 0;
                this.speechOpacity = 0;
            }

            update(canvasWidth, canvasHeight, allCharacters) {
                // Handle Behavior States
                if (this.state === 'WANDERING') {
                    this.move(canvasWidth, canvasHeight);
                    this.handleCollisions(allCharacters);
                    this.updateAnimation();
                } else if (this.state === 'PREPARING') {
                    this.updateAnimation(); // Idle animation
                } else if (this.state === 'TALKING') {
                    // Count down speech visibility
                    if (Date.now() > this.speechTimer) {
                        this.state = 'WANDERING';
                        this.pickNewRandomDirection();
                    }
                }
            }

            move(width, height) {
                this.x += this.vx;
                this.y += this.vy;

                // Boundary Bounce
                if (this.x < HITBOX_RADIUS) { this.x = HITBOX_RADIUS; this.vx *= -1; }
                if (this.x > width - HITBOX_RADIUS) { this.x = width - HITBOX_RADIUS; this.vx *= -1; }
                if (this.y < HITBOX_RADIUS) { this.y = HITBOX_RADIUS; this.vy *= -1; }
                if (this.y > height - HITBOX_RADIUS) { this.y = height - HITBOX_RADIUS; this.vy *= -1; }

                // Random direction change occasionally
                if (Math.random() < 0.01) this.pickNewRandomDirection();
            }

            pickNewRandomDirection() {
                const angle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * SPEED;
                this.vy = Math.sin(angle) * SPEED;
            }

            handleCollisions(others) {
                for (let other of others) {
                    if (other.id === this.id) continue;

                    let dx = other.x - this.x;
                    let dy = other.y - this.y;
                    let distance = Math.sqrt(dx*dx + dy*dy);
                    let minDistance = HITBOX_RADIUS * 2;

                    if (distance < minDistance) {
                        // Collision detected: Push apart
                        let angle = Math.atan2(dy, dx);
                        
                        let targetX = this.x + Math.cos(angle) * minDistance;
                        let targetY = this.y + Math.sin(angle) * minDistance;
                        
                        let ax = (targetX - other.x) * 0.05;
                        let ay = (targetY - other.y) * 0.05;

                        this.vx -= ax;
                        this.vy -= ay;
                        other.vx += ax;
                        other.vy += ay;
                    }
                }
            }

            updateAnimation() {
                // Determine Row based on Velocity
                if (Math.abs(this.vx) > Math.abs(this.vy)) {
                    this.row = this.vx > 0 ? 3 : 1; // Right : Left
                } else {
                    this.row = this.vy > 0 ? 2 : 0; // Down : Up
                }

                // Cycle Frames
                this.tickCount += ANIMATION_SPEED;
                if (this.tickCount > 1) {
                    this.tickCount = 0;
                    this.frameIndex = (this.frameIndex + 1) % 9;
                }
            }

            // Triggered by User
            ask(question) {
                const response = this.brain.thinkOfAnswer(question);
                
                // Staggered Delay: 0 to 2000ms
                const delay = Math.random() * 2000;
                
                this.state = 'PREPARING';
                // Stop moving
                this.vx = 0;
                this.vy = 0;

                setTimeout(() => {
                    this.speechText = response;
                    this.state = 'TALKING';
                    this.speechTimer = Date.now() + 5000; // Show for 5 seconds
                }, delay);
            }

            draw(ctx) {
                // Calculate Perspective Scale
                // Characters at top (y=0) are 70% size, at bottom (y=height) are 110% size
                const perspectiveScale = 0.7 + (this.y / ctx.canvas.height) * 0.4;
                
                const currentW = CHAR_WIDTH * perspectiveScale;
                const currentH = CHAR_HEIGHT * perspectiveScale;

                // 1. Draw Shadow
                ctx.fillStyle = "rgba(0,0,0,0.3)";
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, 12 * perspectiveScale, 6 * perspectiveScale, 0, 0, Math.PI * 2);
                ctx.fill();

                // 2. Draw Sprite or Fallback
                // Check if image is loaded AND has natural dimensions (meaning file exists)
                if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    // Source coordinates from sprite sheet (Assumes 64px frames in source)
                    // We assume standard frame size 64x64 for calculation, adjust if your PNG is different
                    const frameW = this.image.width / 9;
                    const frameH = this.image.height / 4;
                    
                    const sx = this.frameIndex * frameW; 
                    const sy = this.row * frameH; 

                    // Destination (Scaled)
                    const dx = this.x - (currentW / 2); 
                    const dy = this.y - (currentH * 0.9); // Anchor near bottom of sprite
                    
                    ctx.drawImage(this.image, sx, sy, frameW, frameH, dx, dy, currentW, currentH);
                } else {
                    // Fallback Box (If image missing)
                    ctx.fillStyle = "#4488ff";
                    ctx.fillRect(this.x - (15 * perspectiveScale), this.y - (30 * perspectiveScale), 30 * perspectiveScale, 60 * perspectiveScale);
                }

                // 3. Draw Speech Bubble (if Talking)
                if (this.state === 'TALKING') {
                    this.drawSpeechBubble(ctx, currentH, perspectiveScale);
                }
            }

            drawSpeechBubble(ctx, charHeight, scale) {
                const text = this.speechText;
                ctx.font = `${12 * scale + 4}px Arial`; // Scale font slightly
                const textMetrics = ctx.measureText(text);
                const padding = 10 * scale;
                const bubbleWidth = textMetrics.width + (padding * 2);
                const bubbleHeight = 20 * scale + 10;
                
                const bubbleX = this.x - bubbleWidth / 2;
                // Position bubble above the scaled character
                const bubbleY = this.y - charHeight - bubbleHeight - 5;

                // Bubble background
                ctx.fillStyle = "white";
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 2;
                
                // Round Rect Bubble
                ctx.beginPath();
                ctx.roundRect(bubbleX, bubbleY, bubbleWidth, bubbleHeight, 10);
                ctx.fill();
                ctx.stroke();

                // Triangle Pointer
                ctx.beginPath();
                ctx.moveTo(this.x, bubbleY + bubbleHeight);
                ctx.lineTo(this.x - 5, bubbleY + bubbleHeight + 5);
                ctx.lineTo(this.x + 5, bubbleY + bubbleHeight + 5);
                ctx.fill();

                // Text
                ctx.fillStyle = "black";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(text, this.x, bubbleY + (bubbleHeight/2));
            }
        }

        /**
         * WORLD: Manages the game loop and global state.
         */
        class World {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.characters = [];
                this.spriteImage = new Image();
                
                this.resize();
                window.addEventListener('resize', () => this.resize());

                // Load Assets
                this.spriteImage.src = SPRITE_SRC;
                // Simple log to help debugging
                this.spriteImage.onload = () => console.log("Sprite loaded successfully");
                this.spriteImage.onerror = () => console.log("Sprite failed to load - using fallback rectangles");

                // Initialize Characters
                this.initCharacters();

                // Input Handling
                document.getElementById('ask-btn').addEventListener('click', () => this.handleAsk());

                // Start Loop
                this.lastTime = 0;
                this.animate = this.animate.bind(this);
                requestAnimationFrame(this.animate);
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            initCharacters() {
                for (let i = 0; i < NUM_CHARACTERS; i++) {
                    const x = Math.random() * this.canvas.width;
                    const y = Math.random() * this.canvas.height;
                    this.characters.push(new Character(i, x, y, this.spriteImage));
                }
            }

            handleAsk() {
                const input = document.getElementById('question-input');
                const question = input.value;
                if (!question.trim()) return;

                // Trigger thinking process for all characters
                this.characters.forEach(char => char.ask(question));
                
                // Optional: Clear input
                // input.value = ''; 
            }

            animate(timestamp) {
                const deltaTime = timestamp - this.lastTime;
                this.lastTime = timestamp;

                // Clear Canvas
                this.ctx.fillStyle = "#333333";
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Update Physics
                this.characters.forEach(char => char.update(this.canvas.width, this.canvas.height, this.characters));

                // Sort for Z-Index (2.5D Perspective)
                // Characters with higher Y (lower on screen) drawn last (on top)
                this.characters.sort((a, b) => a.y - b.y);

                // Draw
                this.characters.forEach(char => char.draw(this.ctx));

                requestAnimationFrame(this.animate);
            }
        }

        // Start the Game
        window.onload = () => {
            const world = new World();
        };

    </script>
</body>
</html>